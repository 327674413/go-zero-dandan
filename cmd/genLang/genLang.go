package main

import (
	"fmt"
	"github.com/BurntSushi/toml"
	"go-zero-dandan/common/fmtd"
	"go-zero-dandan/common/lang"
	"os"
	"os/exec"
	"sort"
	"text/template"
)

var langCnMap map[string]string

func init() {
	langCnMap = make(map[string]string)
	//先根据code从小到大排序，让排序好看
	sort.Slice(lang.Errs, func(i, j int) bool {
		return lang.Errs[i].Value < lang.Errs[j].Value
	})
	sort.Slice(lang.Fields, func(i, j int) bool {
		return lang.Fields[i].Value < lang.Fields[j].Value
	})
	//用map方便取用
	for _, v := range lang.Errs {
		langCnMap[v.Value] = v.Label
	}
	for _, v := range lang.Fields {
		langCnMap[v.Value] = v.Label
	}
}
func main() {
	genMsg()
	genLang("zh_cn", true)
	genLang("en_us", false)
}
func genMsg() {
	const msgPath = "/Users/yelin/go_dev/project/src/go-zero-dandan/common/resd/msg_gen.go"
	msgFile, err := os.Create(msgPath)
	if err != nil {
		fmtd.Fatal("Error creating file:", err)
		return
	}
	defer msgFile.Close()
	//下面循环的地方加横岗可以去掉前后换行
	msgTemp := `// Code generated by lang.go. DO NOT EDIT.
package resd

func init() {
	msg = make(map[int]string)
	{{- range .errList}}
	msg[{{.Value}}] = "{{.Value}}"
	{{- end}}
}
const (
	{{- range .errList}}
	{{.Value}} = {{.Code}} // {{with $val := index $.langCnMap .Value}}{{$val}}{{end}}
	{{- end}}
)
const (
	{{- range .fieldList}}
	{{.Value}} = "{{.Value}}" // {{with $val := index $.langCnMap .Value}}{{$val}}{{end}}
	{{- end}}
)
`
	// 解析模板
	msgTmpl, err := template.New("msg").Parse(msgTemp)
	if err != nil {
		fmtd.Fatal("Error parsing template:", err)
		return
	}

	// 将模板应用于数据并写入文件
	err = msgTmpl.Execute(msgFile, map[string]any{
		"errList":   lang.Errs,
		"fieldList": lang.Fields,
		"langCnMap": langCnMap,
	})

	if err != nil {
		fmtd.Fatal("Error executing template:", err)
		return
	}

	// 确保文件成功写入后再关闭
	err = msgFile.Close() // 先关闭文件再格式化
	if err != nil {
		fmtd.Fatal("Error closing file:", err)
		return
	}

	// 格式化生成的文件
	cmd := exec.Command("gofmt", "-w", msgPath)
	err = cmd.Run()
	if err != nil {
		fmtd.Fatal("Error formatting file with gofmt:", err)
		return
	}

	fmt.Println("gen msg success")
}

func genLang(langName string, isCn bool) {
	var cnTomlPath = "/Users/yelin/go_dev/project/src/go-zero-dandan/common/lang/" + langName + ".toml"
	tomlData, err := os.ReadFile(cnTomlPath)
	if err != nil {
		fmtd.Fatal("Error reading toml file:", err)
		return
	}
	tomlMap := make(map[string]string)
	err = toml.Unmarshal(tomlData, &tomlMap)
	if err != nil {
		fmt.Println("解析", cnTomlPath, "失败")
	}
	langContent := ""
	emptyContent := ""
	for _, lang := range lang.Errs {
		message := tomlMap[lang.Value]
		if message != "" {
			langContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, message)
		} else if isCn && langCnMap[lang.Value] != "" {
			langContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, langCnMap[lang.Value])
		} else {
			emptyContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, "")
		}

	}
	for _, lang := range lang.Fields {
		message := tomlMap[lang.Value]
		if message != "" {
			langContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, message)
		} else if isCn && langCnMap[lang.Value] != "" {
			langContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, langCnMap[lang.Value])
		} else {
			emptyContent += fmt.Sprintf("%s = \"%s\"\n", lang.Value, "")
		}
	}
	langContent += "\n\n" + emptyContent
	err = os.WriteFile(cnTomlPath, []byte(langContent), 0644)
	if err != nil {
		fmtd.Fatal(langName, "Error writing to toml file:", err)
		return
	}

	fmt.Println("gen ", langName, " success")
}
